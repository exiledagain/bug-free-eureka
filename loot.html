<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon"> 
    <link rel="stylesheet" href="css/common.css">
    <script src="item.js"></script>
    <script src="d2data.js"></script>
    <script src="igen.js"></script>
    <script src="util.js"></script>
  </head>
  <body>
    <script>
      class DropAbacus {
        static constants = {
          'Unique': 250,
          'Set': 500,
          'Rare': 600,
          'Magic': 0
        }
        static itemKeys = Array.from({ length: 10 }, (_, id) => `Item${id + 1}`)
        static probKeys = Array.from({ length: 10 }, (_, id) => `Prob${id + 1}`)
        static monLevelKeys = Array.from({ length: 3 }, (_, id) => `MonLvl${id + 1}Ex`)
        static monNormalKeys = Array.from({ length: 25 }, (_ , id) => `mon${id + 1}`)
        static monHellKeys = Array.from({ length: 25 }, (_ , id) => `nmon${id + 1}`)
        static monUniqueKeys = Array.from({ length: 25 }, (_ , id) => `umon${id + 1}`)
        static monBossLevelKeys = ['Level', 'Level(N)', 'Level(H)']
        static monNormalTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}`)
        static monNightmareTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}(N)`)
        static monHellTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}(H)`)
        static monTreasureKeys = DropAbacus.monHellTreasureKeys.concat(DropAbacus.monNightmareTreasureKeys, DropAbacus.monNormalTreasureKeys)
        static monMinionKeys = ['minion1', 'minion2']
        static monKeys = DropAbacus.monNormalKeys.concat(DropAbacus.monHellKeys)

        constructor (version) {
          this.version = version
          this.loader = new DataLoader()          
        }

        async load () {
          await this.loader.preload(this.version, [
            'Armor.txt',
            'ItemRatio.txt',
            'ItemTypes.txt',
            'Levels.txt',
            'Misc.txt',
            'MonStats.txt',
            'SetItems.txt',
            'TreasureClassEx.txt',
            'UniqueItems.txt',
            'Weapons.txt',
            'SuperUniques.txt'
          ])

          this.itemRatio = this.loader.get(this.version, 'ItemRatio.txt')
          this.typeList = new TypeList(this.loader.get(this.version, 'Misc.txt'), this.loader.get(this.version, 'ItemTypes.txt'))
          this.weapons = this.loader.get(this.version, 'Weapons.txt')
          this.armors = this.loader.get(this.version, 'Armor.txt')
          this.misc = this.loader.get(this.version, 'Misc.txt')
          this.treasure = this.loader.get(this.version, 'TreasureClassEx.txt')
          this.monsters = this.loader.get(this.version, 'MonStats.txt')
          this.levels = this.loader.get(this.version, 'Levels.txt')
          this.sourcer = new MonsterSourcer(this.levels, this.monsters)

          const monsters = []
          this.levels.each(level => {
            if (level.Name === 'Null') {
              return
            }
            monsters.push(this.sourcer.monsters(level.Name))
          })
          console.log(monsters.flat(Infinity))

          this.codeLookup = {}
          this.weapons.each(weapon => {
            this.codeLookup[weapon.code] = weapon
          })
          this.armors.each(armor => {
            this.codeLookup[armor.code] = armor
          })
          this.misc.each(misc => {
            this.codeLookup[misc.code] = misc
          })
          const treasureGraph = new Graph()
          this.treasure.each(treasure => {
            if (treasure.Picks === '0' || treasure.Picks.length === 0) {
              return
            }
            DropAbacus.itemKeys.forEach((key, idx) => {
              if (treasure[key].length > 0 && treasure[DropAbacus.probKeys[idx]] > 0) {                
                treasureGraph.edge(treasure['Treasure Class'], treasure[key])
              }
            })
          })
          const set = new Set()
          console.log(DropAbacus.monTreasureKeys)
          const map = new Map()
          this.monsters.each(monster => {
            if (monster.isSpawn !== '1' || monster.killable !== '1' || monster.enabled !== '1') {
              return
            }
            map.set(monster.Id, monster)
            if (monster.placespawn === '1' && monster.spawn.length > 0) {
            }
            if (monster.SplEndDeath === '1') {
            }
            DropAbacus.monMinionKeys.forEach(key => {
              if (monster[key]) {
              }
            })
            DropAbacus.monTreasureKeys.forEach(key => {
              if (monster[key]) {
                set.add(monster[key])
                treasureGraph.edge(monster.Id, monster[key])
              }
            })
          })
          const mset = new Set()
          this.levels.each(level => {
            DropAbacus.monKeys.forEach(key => {
              if (level[key] && map.has(level[key])) {
                mset.add(level[key])
                treasureGraph.edge(level.Name, level[key])
              }
            })
          })
          console.log(mset)
          treasureGraph.top()
        }

        data () {
          return [
            // this.loader.get(this.version, 'ItemRatio.txt'),
            // this.loader.get(this.version, 'ItemTypes.txt')
            // this.loader.get(this.version, 'Misc.txt'),
            // this.loader.get(this.version, 'Weapons.txt'),
            // this.loader.get(this.version, 'TreasureClassEx.txt'),
            this.loader.get(this.version, 'MonStats.txt'),
            this.loader.get(this.version, 'Levels.txt'),
            this.loader.get(this.version, 'SuperUniques.txt'),
          ] 
        }

        isClassSpecific (item) {
          if (!this.typeList.has(item)) {
            item = this.codeLookup[item].type
          }
          return this.typeList.expand('clas').includes(item)
        }

        getType (item) {
          let res = item
          this.weapons.each(weapon => {
            if (weapon.code === item) {
              res = weapon.type1
            }
          })
          if (res !== item) {
            return res
          }
          this.armors.each(armor => {
            if (armor.code === item) {
              res = armor.type1
            }
          })
          return res
        }

        getItemRatio (item, rarity) {
          const clazzy = this.isClassSpecific(item)
          let res
          this.itemRatio.each(ratio => {
            if (ratio.Version === '1' && (ratio['Class Specific'] === '1' && clazzy)) {
              res = ratio
            } else if (ratio.Version === '1' && ratio['Class Specific'] !== '1') {
              res = ratio
            }
          })
          return {
            base: Number(res[rarity]),
            divisor: Number(res[`${rarity}Divisor`]),
            min: Number(res[`${rarity}Min`]),
            class: clazzy,
            raw: res
          }
        }

        getItemLevel (item) {
          return Number(this.codeLookup[item].level)
        }

        p (rarity, magicFind, level, extra, item) {
          const ratio = this.getItemRatio(item, rarity)
          return this.chance(magicFind, extra, level - this.getItemLevel(item), rarity, ratio.base, ratio.divisor, ratio.min, DropAbacus.constants[rarity])
        }

        chance (magicFind, extra, difference, rarity, rarityBase, divisor, min, cs) {
          const constant = DropAbacus.constants[rarity]
          const effectiveMF = rarity !== 'Magic' ? Math.floor(magicFind * constant / (magicFind + constant)) : magicFind
          const div = Math.floor(difference / divisor)
          const chance = Math.max(min, Math.floor((rarityBase - div) * 12800 / (100 + effectiveMF)))
          const final = chance - Math.floor((chance * extra) / 1024)
          return final > 128 ? 128 / final : 1
        }
      }

      class DropView {
        constructor (abacus) {
          this.abacus = abacus
        }

        populate (container) {
          for (const data of this.abacus.data()) {
            new DataView(data).populate(container)
          }
        }
      }

      async function Load () {
        const abacus = new DropAbacus('s8')
        await abacus.load()
        requestAnimationFrame(() => {
          const view = new DropView(abacus)
          view.populate(document.body)
        })
        const code = '7tw'
        const level = 89
        const extra = 100
        const find = 155
        console.log(abacus.p('Unique', find, level, extra, code))
        console.log(abacus.p('Set', find, level, extra, code))
        console.log(abacus.p('Rare', find, level, extra, code))
        console.log(abacus.p('Magic', find, level, extra, code))
      }
      requestAnimationFrame(Load)
    </script>
  </body>
</html>
