<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon"> 
    <link rel="stylesheet" href="css/common.css">
    <script src="item.js"></script>
    <script src="d2data.js"></script>
    <script src="igen.js"></script>
    <script src="util.js"></script>
  </head>
  <body>
    <script>
      'use strict'

      class DropAbacus {
        static constants = {
          'Unique': 250,
          'Set': 500,
          'Rare': 600,
          'Magic': 0
        }
        static itemKeys = Array.from({ length: 10 }, (_, id) => `Item${id + 1}`)
        static probKeys = Array.from({ length: 10 }, (_, id) => `Prob${id + 1}`)
        static monLevelKeys = Array.from({ length: 3 }, (_, id) => `MonLvl${id + 1}Ex`)
        static monNormalKeys = Array.from({ length: 25 }, (_ , id) => `mon${id + 1}`)
        static monHellKeys = Array.from({ length: 25 }, (_ , id) => `nmon${id + 1}`)
        static monUniqueKeys = Array.from({ length: 25 }, (_ , id) => `umon${id + 1}`)
        static monBossLevelKeys = ['Level', 'Level(N)', 'Level(H)']
        static monNormalTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}`)
        static monNightmareTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}(N)`)
        static monHellTreasureKeys = Array.from({ length: 4 }, (_, id) => `TreasureClass${id + 1}(H)`)
        static monTreasureKeys = DropAbacus.monHellTreasureKeys.concat(DropAbacus.monNightmareTreasureKeys, DropAbacus.monNormalTreasureKeys)
        static monMinionKeys = ['minion1', 'minion2']
        static monKeys = DropAbacus.monNormalKeys.concat(DropAbacus.monHellKeys)

        constructor (version) {
          this.version = version
          this.loader = new DataLoader()          
        }

        async load () {
          await this.loader.preload(this.version, [
            'Armor.txt',
            'ItemRatio.txt',
            'ItemTypes.txt',
            'Levels.txt',
            'Misc.txt',
            'MonStats.txt',
            'SetItems.txt',
            'TreasureClassEx.txt',
            'UniqueItems.txt',
            'Weapons.txt',
            'SuperUniques.txt'
          ])

          this.itemRatio = this.loader.get(this.version, 'ItemRatio.txt')
          this.weapons = this.loader.get(this.version, 'Weapons.txt')
          this.armors = this.loader.get(this.version, 'Armor.txt')
          this.misc = this.loader.get(this.version, 'Misc.txt')
          this.treasure = this.loader.get(this.version, 'TreasureClassEx.txt')
          this.monsters = this.loader.get(this.version, 'MonStats.txt')
          this.levels = this.loader.get(this.version, 'Levels.txt')
          this.uniques = this.loader.get(this.version, 'UniqueItems.txt')
          this.sets = this.loader.get(this.version, 'SetItems.txt')
          this.types = this.loader.get(this.version, 'ItemTypes.txt')

          this.typeList = new TypeList(this.misc, this.types, this.weapons, this.armors)
          this.sourcer = new MonsterSourcer(this.levels, this.monsters)
          this.tree = new TreasureTree(this.treasure)

          const walked = {}
          let monsters = []
          this.levels.each(level => {
            if (level.Name === 'Null') {
              return
            }
            monsters.push(this.sourcer.monsters(level.Name))
          })
          monsters = monsters.flat(Infinity)
          let pres = 0
          const dropMap = new Map()
          monsters.forEach(monster => {
            monster.treasure = this.tree.upgrade(monster.treasure, monster.level)
            if (this.tree.has(monster.treasure) && !walked[monster.treasure]) {
              walked[monster.treasure] = true
              this.tree.walk(monster.treasure, 1, {
                pre: (treasure) => {
                  const ret = dropMap.get(treasure.id)
                  const val = { treasure, ancestor: monster.treasure }
                  if (!ret) {
                    dropMap.set(treasure.id, [ val ])
                  } else {
                    ret.push(val)
                  }                  
                },
                post: () => {
                }
              })
            }
          })
          this.dropMap = dropMap

          this.codeMap = {}
          this.wearMap = {}
          this.weapons.each(weapon => {
            this.codeMap[weapon.code] = weapon
            this.wearMap[weapon.code] = weapon
          })
          this.armors.each(armor => {
            this.codeMap[armor.code] = armor
            this.wearMap[armor.code] = armor
          })
          this.misc.each(misc => {
            this.codeMap[misc.type] = misc
          })

          this.uniqueMap = {}
          this.uniques.each(unique => {
            if (unique.enabled !== '1' || unique.rarity < 1) {
              return
            }
            this.uniqueMap[unique.code] = this.uniqueMap[unique.code] || []
            this.uniqueMap[unique.code].push({
              id: unique.index,
              level: Number(unique.lvl),
              p: Number(unique.rarity)
            })
          })

          this.setMap = {}
          this.sets.each(set => {
            if (set.rarity < 1) {
              return
            }
            this.setMap[set.item] = this.setMap[set.item] || []
            this.setMap[set.item].push({
              id: set.index,
              level: Number(set.lvl),
              p: Number(set.rarity)
            })
          })
        }

        data () {
          return [
            // this.loader.get(this.version, 'ItemRatio.txt'),
            this.loader.get(this.version, 'ItemTypes.txt'),
            this.loader.get(this.version, 'Misc.txt'),
            // this.loader.get(this.version, 'Weapons.txt'),
            // this.loader.get(this.version, 'Armor.txt'),
            // this.loader.get(this.version, 'TreasureClassEx.txt'),
            // this.loader.get(this.version, 'MonStats.txt'),
            // this.loader.get(this.version, 'Levels.txt'),
            // this.loader.get(this.version, 'SuperUniques.txt'),
            // this.loader.get(this.version, 'SetItems.txt'),
            // this.loader.get(this.version, 'UniqueItems.txt'),
          ] 
        }

        isClassSpecific (item) {
          if (!this.typeList.has(item)) {
            item = this.codeMap[item].type
          }
          return this.typeList.expand('clas').includes(item)
        }

        getType (item) {
          let type
          type = this.weapons.first('code', item)
          if (type) {
            return this.types.first('Code', 'weap')
          }
          type = this.armors.first('code', item)
          if (type) {
            return this.types.first('Code', 'armo')
          }
          const misc = this.misc.first('code', item)
          if (misc) {
            return this.types.first('Code', misc.type)
          }
          return this.types.first('Code', item)
        }

        getItemRatio (item, rarity) {
          const clazzy = this.isClassSpecific(item)
          let res
          this.itemRatio.each(ratio => {
            if (ratio.Version === '1' && (ratio['Class Specific'] === '1' && clazzy)) {
              res = ratio
            } else if (ratio.Version === '1' && ratio['Class Specific'] !== '1') {
              res = ratio
            }
          })
          return {
            base: Number(res[rarity]),
            divisor: Number(res[`${rarity}Divisor`]),
            min: Number(res[`${rarity}Min`]),
            class: clazzy,
            raw: res
          }
        }

        getItemLevel (item) {
          return Number(this.codeMap[item].level)
        }

        p (rarity, magicFind, level, extra, item) {
          const ratio = this.getItemRatio(item, rarity)
          return this.chance(magicFind, extra, level - this.getItemLevel(item), rarity, ratio.base, ratio.divisor, ratio.min, DropAbacus.constants[rarity])
        }

        chance (magicFind, extra, difference, rarity, rarityBase, divisor, min, cs) {
          const constant = DropAbacus.constants[rarity]
          const effectiveMF = rarity !== 'Magic' ? Math.floor(magicFind * constant / (magicFind + constant)) : magicFind
          const div = Math.floor(difference / divisor)
          const chance = Math.max(min, Math.floor((rarityBase - div) * 12800 / (100 + effectiveMF)))
          const final = chance - Math.floor((chance * extra) / 1024)
          return final > 128 ? 128 / final : 1
        }

        mustBeNormal (code) {
          const type = this.getType(code)
          return type.Normal === '1'
        }

        mustBeMagic (code) {
          const type = this.getType(code)
          return type.Magic === '1'
        }

        mustBeUnique (code) {
          const weapon = this.weapons.first('code', code)
          if (weapon && weapon.unique === '1') {
            return true
          }
          const armor = this.armors.first('code', code)
          if (armor && armor.unique === '1') {
            return true
          }
          // also need magic flag?
          if ((weapon && weapon.quest > 0) || (armor && armor.quest > 0)) {
            return true
          }
          return false
        }

        // don't think anything quest related or forcibly unique can drop from a tc
        can (code, rarity) {
          const typeId = this.getType(code)
          switch (rarity) {
            case 'Unique': {
              return !this.mustBeNormal(code) && !this.mustBeMagic(code) && !!this.uniqueMap[code]
            }
            case 'Set': {
              return !this.mustBeNormal(code) && !this.mustBeMagic(code) && !this.mustBeUnique(code) && !!this.setMap[code]
            }
            case 'Rare': {
              const type = this.getType(code)
              return !this.mustBeNormal(code) && !this.mustBeMagic(code) && !this.mustBeUnique(code) && type.Rare === '1'
            }
            case 'Magic': {
              return !this.mustBeNormal(code) && !this.mustBeUnique(code)
            }
            case 'Normal': {
              return !this.mustBeMagic(code) && !this.mustBeUnique(code)
            }
          }
          throw new Error(`unknown rarity: ${rarity}`)
        }

        drop (find, code, rarity) {
          if (!this.can(code, rarity)) {
            return []
          }
          const res = []

          return res
        }
      }

      class DropView {
        constructor (abacus) {
          this.abacus = abacus
        }

        populate (container) {
          for (const data of this.abacus.data()) {
            new DataView(data).populate(container)
          }
        }
      }

      async function Load () {
        const abacus = new DropAbacus('s8')
        await abacus.load()
        requestAnimationFrame(() => {
          const view = new DropView(abacus)
          view.populate(document.body)
        })
        const code = '7tw'
        const level = 89
        const extra = 100
        const find = 155
        console.log(abacus.can('uar', 'Unique'))
        console.log(abacus.can('swb', 'Set'))
        console.log(abacus.can('uar', 'Rare'))
        console.log(abacus.can('uar', 'Magic'))
        console.log(abacus.can('aqv', 'Normal'))
        console.log(abacus.p('Unique', find, level, extra, code))
        console.log(abacus.p('Set', find, level, extra, code))
        console.log(abacus.p('Rare', find, level, extra, code))
        console.log(abacus.p('Magic', find, level, extra, code))
        console.log(abacus.drop(find, code, 'Normal'))
      }
      requestAnimationFrame(Load)
    </script>
  </body>
</html>
