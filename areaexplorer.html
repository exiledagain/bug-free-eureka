<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <script src="d2data.js"></script>
  </head>
  <body>
    <a href="https://github.com/exiledagain/bug-free-eureka" target="_blank" rel="noopener noreferrer">source</a>
    <div id="main"></div>
    <div id="main1"></div>
    <script>
      function populateForm (container, { name, spec }) {
        const form = document.createElement('form')
        const fieldset = document.createElement('fieldset')
        const legend = document.createElement('legend')
        const table = document.createElement('table')
        form.autocomplete = "off"
        form.style.width = 'fit-content'
        legend.textContent = name
        const list = {}
        spec.forEach(({ display, name, input }) => {
          const row = document.createElement('tr')
          const key = document.createElement('td')
          const value = document.createElement('td')
          const label = document.createElement('label')
          label.setAttribute('for', name)
          label.textContent = display
          const valueEl = input(list)
          list[name] = valueEl
          valueEl.id = name
          valueEl.setAttribute('name', name)
          key.appendChild(label)
          value.appendChild(valueEl)
          row.appendChild(key)
          row.appendChild(value)
          table.appendChild(row)
        })
        fieldset.appendChild(legend)
        fieldset.appendChild(table)
        form.appendChild(fieldset)
        container.appendChild(form)
        form.onsubmit = e => {
          e.preventDefault()
          return false
        }
        return {
          form,
          inputs: list
        }
      }
      class AreaView {
        static resistanceNames = ['Phys', 'Magic', 'Fire', 'Light', 'Cold', 'Poison']
        static resistance = ['ResDm', 'ResMa', 'ResFi', 'ResLi', 'ResCo', 'ResPo']
        static difficulty = ['', '(N)', '(H)']
        static health = [
          ['minHP', 'maxHP'],
          ['MinHP', 'MaxHP'],
          ['MinHP', 'MaxHP']
        ]
        static rarityHpMod = [
          [1, 3, 4, 1, 1, 2],
          [1, 2.5, 3, 1, 1, 1.75],
          [1, 2, 2, 1, 1, 1.5]
        ]
        static applyOrder = ['Cold', 'Fire', 'Light']

        constructor ({ d2data, strings, sourcer, values, monsterLevel, extended }) {
          this.d2data = d2data
          this.strings = strings
          this.sourcer = sourcer
          this.values = values
          this.levels = sourcer.levelData
          this.monsters = sourcer.monsterData
          this.monsterLevel = monsterLevel
          this.extended = extended
        }

        applyUMod (umodId, reses) {
          umodId = Number(umodId)
          let immuneCount = AreaView.resistanceNames.reduce((sum, name) => sum + (reses[name] > 99), 0)
          if (immuneCount >= 2) {
            return
          }
          switch (umodId) {
            case 8:
            case 27: {
              const maxRes = umodId === 28 ? 75 : 100
              const delta = umodId === 28 ? 20 : 40

              AreaView.applyOrder.forEach(res => {
                if (immuneCount < 2 && reses[res] < maxRes) {
                  reses[res] += delta
                  if (reses[res] > 99) {
                    immuneCount += 1
                  }
                }
              })
              break
            }
            case 9: {
              reses['Fire'] += 75
              break
            }
            case 17: {
              reses['Light'] += 75
              break
            }
            case 18: {
              reses['Cold'] += 75
              break
            }
            case 23: {
              reses['Poison'] += 75
              break
            }
            case 25: {
              reses['Magic'] += 20
              break
            }
            case 28: {
              reses['Phys'] += 50
              break
            }
          }
        }

        populate (container) {
          const level = this.levels.first('Name', this.values.zone)
          const difficulty = Number(this.values.difficulty)
          const players = Number(this.values.party)
          const monsters = this.sourcer.monsters(level.Name).reduce((list, monster) => {
            const passingType = monster.special || monster.rarity === 0
            if (!(passingType && monster.difficulty === difficulty)) {
              return list
            }
            const entry = this.monsters.first('Id', monster.id)
            const monLvl = this.monsterLevel.first('Level', Math.min(110, monster.baseLevel).toString())
            const Name = this.strings.readable(monster.string)
            const Level = monster.level
            const reses = Object.fromEntries(AreaView.resistanceNames.map((res, idx) => {
              const key = `${AreaView.resistance[idx]}${AreaView.difficulty[difficulty]}`
              return [res, Number(entry[key])]
            }))
            const hps = Object.fromEntries(AreaView.health[difficulty].map((hp, idx) => {
              const key = `${hp}${AreaView.difficulty[difficulty]}`
              const ratio = entry.noRatio === '1' ? 1 : (monLvl[`L-HP${AreaView.difficulty[difficulty]}`])
              const typeMod = entry.boss === '1' ? 1 : AreaView.rarityHpMod[this.values.difficulty][monster.rarity]
              const health = (entry[key] * ratio * (1 + (players - 1) * 0.7) * typeMod) / 100
              return [hp.substring(0, 1).toUpperCase() + hp.substring(1), ~~health]
            }))
            const xps = Object.fromEntries(['Exp'].map((xp, idx) => {
              const key = `${xp}${AreaView.difficulty[difficulty]}`
              const ratio = entry.noRatio === '1' ? 1 : (monLvl[`L-XP${AreaView.difficulty[difficulty]}`] / 100)
              const exp = ~~(Number(entry[key]) * ratio * (1 + (players - 1) * 0.5))
              return [xp, exp]
            }))
            const block = Object.fromEntries(['Block'].map(block => {
              const rate = new MonsterMetrics(this.monsters, this.extended).blockRate({ name: entry.Id })
              return [block, `${rate[difficulty] || 0}%`]
            }))
            const chill = Object.fromEntries(['Chill'].map(chill => {
              const key = `coldeffect${AreaView.difficulty[difficulty]}`
              const rate = `${entry[key] || 0}%`
              return [chill, rate]
            }))
            const Type = entry['lUndead'] === '1' || entry['hUndead'] === '1' ? 'Undead' : entry['demon'] === '1' ? 'Demon' : 'None'
            const Leech = `${Math.max(0, Number(entry[`Drain${AreaView.difficulty[difficulty]}`]))}%`
            const PrimeEvil = ~~(entry['primeevil'] === '1')
            const Id = monster.id
            if (monster.superUnique) {
              const sus = this.d2data.supers()
              for (let i = 1; i <= 3; ++i) {
                const mod = `Mod${i}`
                this.applyUMod(sus.first('Superunique', monster.superUnique)[mod], reses)
              }
            }
            AreaView.resistanceNames.forEach(name => {
              reses[name] = `${reses[name]}%`
            })
            list.push({
              Name,
              Level,
              ...xps,
              ...hps,
              ...reses,
              ...chill,
              ...block,
              Leech,
              Type,
              PrimeEvil,
              Id,
            })
            return list
          }, [])
          this.populateTable(container, [this.strings.readable(level.LevelName)].join(' - '), monsters)
        }

        populateTable (container, name, monsters) {
          const headers = new Set()
          monsters.forEach(monster => {
            Object.keys(monster).forEach(key => {
              headers.add(key)
            })
          })
          window.lastMonsters = monsters
          const fieldset = document.createElement('fieldset')
          const legend = document.createElement('legend')
          const table = document.createElement('table')
          const thead = document.createElement('thead')
          const tbody = document.createElement('tbody')
          legend.textContent = name
          const th = document.createElement('tr')
          headers.forEach(header => {
            const el = document.createElement('th')
            el.style.userSelect = 'none'
            el.textContent = header
            th.appendChild(el)
          })
          monsters.forEach(monster => {
            const row = document.createElement('tr')
            headers.forEach(header => {
              const el = document.createElement('td')
              el.textContent = monster[header]
              row.appendChild(el)
            })
            tbody.appendChild(row)
          })
          thead.appendChild(th)
          table.appendChild(thead)
          table.appendChild(tbody)
          fieldset.appendChild(legend)
          fieldset.appendChild(table)
          fieldset.style.width = 'fit-content'
          container.appendChild(fieldset)
        }
      }
      class AreaExplorerView {
        static actZones = [
          'Act 1 - Town',
          'Act 2 - Town',
          'Act 3 - Town',
          'Act 4 - Town',
          'Act 5 - Town'
        ]

        constructor (container) {
          this.container = container
          this.d2data = new Diablo2Data()
          this.setup()
        }

        async setup () {
          await this.d2data.load()
          this.strings = await this.d2data.StringResolver()
          this.sourcer = this.d2data.MonsterSourcer()
          if (false) {
            const comparisonData = new Diablo2Data('s11')
            await comparisonData.load()
            this.comparison = {
              d2data: comparisonData,
              strings: await comparisonData.StringResolver(),
              sourcer: comparisonData.MonsterSourcer()
            }
          }
          this.zones = [[]]
          let i = 0
          this.sourcer.levelData.each(level => {
            if (!level.Id) {
              return
            }
            if (i < 5 && level.Id === this.sourcer.levelData.first('Name', AreaExplorerView.actZones[i]).Id) {
              this.zones.at(-1).set = new Set(this.zones.at(-1))
              this.zones.push([])
              i += 1
            } else {
              this.zones.at(-1).push({
                raw: level,
                name: this.strings.get(level.LevelName)
              })
            }
          })
          this.zones.shift()
          this.populate()
        }

        populate () {
          this.meta = document.createElement('div')
          this.areas = document.createElement('div')
          this.areasPrev = document.createElement('div')
          this.container.appendChild(this.meta)
          this.container.appendChild(this.areas)
          this.container.appendChild(this.areasPrev)
          this.populateMeta()
        }

        populateMeta () {
          this.meta.innerHTML = ''
          const { form, inputs: {
            difficulty,
            party,
            act,
            zone
          } } = populateForm(this.meta, {
            name: 'Meta',
            spec: [
              {
                display: 'Difficulty',
                name: 'difficulty',
                input: inputs => {
                  const res = document.createElement('select')
                  const difficulties = ['Normal', 'Nightmare', 'Hell']
                  difficulties.forEach((difficulty, idx) => {
                    const el = document.createElement('option')
                    el.value = idx
                    el.textContent = difficulty
                    res.appendChild(el)
                  })
                  res.lastElementChild.selected = true
                  return res
                }
              },
              {
                display: 'Act',
                name: 'act',
                input: inputs => {
                  const res = document.createElement('select')
                  for (let i = 1; i <= 5; ++i) {
                    const el = document.createElement('option')
                    el.value = i - 1
                    el.textContent = `Act ${i}`
                    res.appendChild(el)
                  }
                  res.lastElementChild.selected = true
                  return res
                }
              },
              {
                display: 'Zone',
                name: 'zone',
                input: inputs => {
                  const res = document.createElement('select')
                  this.populateZones(res, inputs.act.value)
                  return res
                }
              },
              {
                display: 'Party',
                name: 'party',
                input: inputs => {
                  const res = document.createElement('select')
                  for (let i = 1; i <= 8; ++i) {
                    const el = document.createElement('option')
                    el.value = i
                    el.textContent = i
                    res.appendChild(el)
                  }
                  return res
                }
              },
            ]
          })
          difficulty.onchange = () => {
            this.populateAreas()
          }
          act.onchange = () => {
            this.populateZones(zone, act.value)
            this.populateAreas()
          }
          zone.onchange = () => {
            this.populateAreas()
          }
          party.onchange = () => {
            this.populateAreas()
          }
          this.form = form
          this.populateAreas()
        }

        populateZones (input, act) {
          const preferred = ''
          let found = false
          input.innerHTML = ''
          this.zones[act].forEach(level => {
            const el = document.createElement('option')
            el.textContent = level.name
            el.value = level.raw.Name
            if (!found && level.name === preferred) {
              el.selected = true
              found = true
            }
            input.appendChild(el)
          })
        }

        populateAreas () {
          this.areas.innerHTML = ''
          new AreaView({
            d2data: this.d2data,
            strings: this.strings,
            sourcer: this.sourcer,
            values: this.values(),
            monsterLevel: this.d2data.monLvl(),
            extended: this.d2data.monStats2(),
          }).populate(this.areas)
          if (this.comparison) {
            this.areasPrev.innerHTML = ''
            new AreaView({
              strings: this.comparison.strings,
              sourcer: this.comparison.sourcer,
              values: this.values(),
              monsterLevel: this.comparison.d2data.monLvl(),
              extended: this.comparison.d2data.monStats2(),
            }).populate(this.areasPrev)
          }
        }

        values () {
          return Object.fromEntries(new FormData(this.form))
        }
      }
      new AreaExplorerView(document.getElementById('main'))
    </script>
  </body>
</html>
