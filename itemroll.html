<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <script src="item.js"></script>
    <script src="d2data.js"></script>
    <script src="igen.js"></script>
  </head>
  <body>
    <button id="enumerate">enumerate</button>
    <p id="content">

    </p>
    <script>
      'use strict'

      const mustSkipRoll = {
        'hit-skill': true,
        'charged': true,
      }

      class RollItem {
        constructor ({ rng, prefixList, suffixList, crafted = false, automod = false }) {
          this.rng = rng
          this.prefixList = this.fromList(prefixList)
          this.suffixList = this.fromList(suffixList)
          this.crafted = crafted
          this.automod = automod
        }

        fromList (list) {
          const res = []
          list.each(el => {
            res.push(el)
          })
          return res
        }

        simulate (skip = false) {
          // rare name
          if (!skip) {
            this.rng.skip(2)
          }
          // crafted roll number of affixes
          if (this.crafted) {
            this.rng.skip(1)
          }
          // assume we always roll max
          const count = this.crafted ? 4 : 6
          // roll prefix, suffix
          const prefixes = []
          const suffixes = []
          for (let i = 0; i < count; ++i) {
            if (!this.crafted) {
              if (suffixes.length < 3 && (prefixes.length > 2 || Number(this.rng.next('prefix/suffix') & BigInt(1)) !== 0)) {
                suffixes.push(this.nextAffix(this.suffixList, suffixes, prefixes))
              } else {
                prefixes.push(this.nextAffix(this.prefixList, prefixes, suffixes))
              }
            } else {
              const choice = Number(this.rng.next('prefix/suffix') & BigInt(1))
              if (prefixes.length === 3 || (suffixes.length < 3 && choice !== 0)) {
                suffixes.push(this.nextAffix(this.suffixList, suffixes, prefixes))
              } else {
                prefixes.push(this.nextAffix(this.prefixList, prefixes, suffixes))
              }
            }
          }
          // roll mod values
          const prefixRolls = []
          const suffixRolls = []
          for (let i = 0; i < 3; ++i) {
            prefixRolls.push(this.properties(prefixes[i]))
            suffixRolls.push(this.properties(suffixes[i]))
          }
          // note: pd2 automod doesn't use item seed rng
          // automod for claws has 31 skills
          if (this.automod) {
            const chance = this.rng.max(100)
            let count = 0
            if (chance < 80) {
              if (chance < 50) {
                if (chance < 10) {
                  count = 0
                } else {
                  count = 1
                }
              } else {
                count = 2
              }
            } else {
              count = 3
            }
            let max = 31
            const chosen = {}
            for (let i = 0; i < count; ++i) {
              for (let j = 0; j < 4; ++j) {
                // todo: can't put poison strike on necro heads
                // todo: required level must be 1 or <= ilvl
                const r = this.rng.max(max)
                if (!chosen[r]) {
                  chosen[r] = true
                  break
                }
              }
              // todo: skill level
              // some condition here: s9+180d59
            }
          }
          if (this.crafted && !this.automod) {
            this.rng.skip(2)
          }
          const craftedRolls = []
          if (this.crafted && !this.automod) {
            // blood: lifesteal=[3,6], hp=[10,20] dmg%=[50,80]
            craftedRolls.push([{ code: 'lifesteal', value: this.rng.max(6 - 3 + 1) + 3 }])
            craftedRolls.push([{ code: 'hp', value: this.rng.max(20 - 10 + 1) + 10 }])
            craftedRolls.push([{ code: 'dmg%', value: this.rng.max(80 - 50 + 1) + 50 }])
          }
          const summary = {}
          const cb = mods => {
            mods.forEach(({ code, value, param }) => {
              summary[code] = summary[code] || { value: 0, param: param || '' }
              summary[code].value += value
            })
          }
          prefixRolls.forEach(cb)
          suffixRolls.forEach(cb)
          craftedRolls.forEach(cb)
          return summary
        }

        properties (affix) {
          if (!affix) {
            return []
          }
          const res = []
          affix.mods.forEach(({ code, min, max, param }) => {
            if (code.length === 0) {
              return
            }
            max = Number(max)
            min = Number(min)
            if (min < max && !mustSkipRoll[code]) {
              if (min > 0 && max > 0) {
                res.push({
                  code,
                  param,
                  value: this.rng.max(max - min + 1) + min
                })
              } else if (min < 0 && max < 0) {
                res.push({
                  code,
                  param,
                  value: this.rng.max(max - min + 1) + min
                })
              } else {
                console.error(code, param, min, max)
                throw new Error('...')
              }
            } else {
              res.push({
                code,
                param,
                value: min
              })
            }
          })
          return res
        }

        nextAffix (list, previous, extra = []) {
          this.rng.next('consume')
          const banned = new Set([previous.map(el => el.row.group), extra.map(el => el.row.group)].flat())
          let sum = 0
          list.forEach(({ row: affix }) => {
            if (banned.has(affix.group)) {
              return
            }
            sum += Number(affix.frequency)
          })
          const roll = Number(this.rng.next('affix roll') % BigInt(sum + 1))
          sum = 0
          let res = -1
          list.some(({ row: affix }, id) => {
            if (banned.has(affix.group)) {
              return
            }
            sum += Number(affix.frequency)
            res = id
            if (sum > roll) {
              return true
            }
          })
          return list[res]
        }
      }
      let started = false
      async function Load () {
        const version = 's9'
        const files = ['Misc.txt', 'ItemTypes.txt', 'MagicPrefix.txt', 'MagicSuffix.txt']
        const loader = new DataLoader()
        await loader.preload(version, files)
        const tl = new TypeList(loader.get(version, 'Misc.txt'), loader.get(version, 'ItemTypes.txt'))
        let setup, meta, requirements
        let prefixList, suffixList
        const prefixData = loader.get(version, 'MagicPrefix.txt')
        const suffixData = loader.get(version, 'MagicSuffix.txt')
        function reload () {
          const itemCode = 'h2h'
          const level = 99
          const isRare = true
          prefixList = new AffixList(tl, prefixData, itemCode, level, isRare)
          suffixList = new AffixList(tl, suffixData, itemCode, level, isRare)
          window.prefixes = prefixList
          window.suffixList = suffixList
          const rng = new D2Random('0x' + 'fafd02e8')
          // rng.reset('0x' + '4B874186A8978A9B')
          // rng.set(...'3460463983 361285771'.split(' '))
          // const crafted = true
          // const automod = true
          // const item = new RollItem({ rng, prefixList, suffixList, crafted, automod }).simulate()
          // console.log(item)
          // const rm = new RollItem({ rng, prefixList, suffixList })
          // const dump = { prefix: rm.prefixList, suffix: rm.suffixList }
          // console.log(JSON.stringify(dump, null, 2))
          document.querySelector('#enumerate').onclick = e => {
            started = !started
            if (started) {
              SimulateAllPossibleMaps()
              e.target.textContent = 'stop (click once)'
            } else {
              e.target.textContent = 'enumerate'
            }
          }
        }
        function WaitForFrame () {
          return new Promise(resolve => {
            requestAnimationFrame(resolve)
          })
        }
        async function WaitForFrames (n) {
          for (let i = 0; i < n; ++i) {
            await WaitForFrame()
          }
        }
        const WaitMs = ms => new Promise(resolve => setTimeout(resolve, ms))
        async function SimulateAllPossibleMaps () {
          const targets = [
            { code: 'dmg%', threshold: 400 },
            { code: 'hit-skill', param: '442' }
          ]
          const el = document.querySelector('#content')
          const MAX = BigInt.asUintN(32, BigInt('0xFFFFFFFFFFFFFFFFFFFFF'))
          const k = BigInt(1e5)
          const rng = new D2Random('0x0')
          const roller = new RollItem({ rng, prefixList, suffixList, crafted: true, automod: true })
          el.style.whiteSpace = 'pre'
          el.textContent = `0 of ${MAX}`
          await WaitForFrames(2)
          const histogram = {}
          const bests = []
          for (let i = BigInt(0); i <= MAX;) {
            const first = i
            const start = performance.now()
            for (let j = 0; j < k && i <= MAX; ++j, ++i) {
              rng.lower(i)
              const item = roller.simulate()
              if (targets.every(target => {
                if (!item[target.code]) {
                  return false
                }
                if (target.param && target.param !== item[target.code].param) {
                  return false
                }
                return !target.threshold || target.threshold <= item[target.code].value
              })) {
                bests.push({
                  value: item[targets[0].code].value,
                  seed: i.toString(16)
                })
              }
              const value = (item[targets[0].code] || { value: 0 }).value
              histogram[value] = histogram[value] || 0
              histogram[value] += 1
            }
            const rem = Number((MAX - i + BigInt(k) - BigInt(1)) / BigInt(k)) * (performance.now() - start) / 1e3
            el.textContent = `${i} of ${MAX}\n\nremaining time: ${rem}\n\n${JSON.stringify(bests, null, 2)}\n\n${JSON.stringify(histogram, null, 2)}`
            if (!started) {
              el.textContent = 'stopped\n' + el.textContent
              return
            }
            await WaitForFrames(2)
          }
          bests.sort((a, b) => b.value - a.value)
          console.log(histogram, bests)
          el.textContent = `done.\n\n${JSON.stringify(bests, null, 2)}\n\n${JSON.stringify(histogram, null, 2)}\n\n`
          document.querySelector('#enumerate').textContent = 'enumerate'
        }
        reload()
      }
      requestAnimationFrame(Load)
    </script>
  </body>
</html>
