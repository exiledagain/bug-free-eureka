<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <script src="d2data.js"></script>
  </head>
  <body>
    <a href="https://github.com/exiledagain/bug-free-eureka" target="_blank" rel="noopener noreferrer">source</a>
    <table>
      <tr>
        <td style="vertical-align: baseline;">
          <form id="configForm" autocomplete="off">
            <fieldset>
              <legend>Config</legend>
              <table>
                <tr>
                  <td>
                    <label for="difficulty">Difficulty</label>
                  </td>
                  <td>
                    <select id="difficulty" name="difficulty">
                      <option value="2" selected>Hell</option>
                      <option value="1">Nightmare</option>
                      <option value="0">Normal</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="players">Party</label>
                  </td>
                  <td>
                    <select id="players" name="players">
                      <option value="1" selected>1</option>
                      <option value="2">2</option>
                      <option value="3">3</option>
                      <option value="4">4</option>
                      <option value="5">5</option>
                      <option value="6">6</option>
                      <option value="7">7</option>
                      <option value="8">8</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="chest">Chest Type</label>
                  </td>
                  <td>
                    <select id="chestType" name="chestType">
                      <option value="normal" selected>Normal</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="chestOpt">Chest Opt</label>
                  </td>
                  <td>
                    <select id="chestOpt" name="chestOpt">
                      <option value="0" selected>Unlocked</option>
                      <option value="1">Locked</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="act">Act</label>
                  </td>
                  <td>
                    <select id="act" name="act">
                      <option value="4" selected>Act 5</option>
                      <option value="3">Act 4</option>
                      <option value="2">Act 3</option>
                      <option value="1">Act 2</option>
                      <option value="0">Act 1</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="Zone">Zone</label>
                  </td>
                  <td>
                    <select id="zone" name="zone">
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="magicFind">Magic Find</label>
                  </td>
                  <td>
                    <input id="magicFind" name="magicFind" type="text" value="0" pattern="\d+" maxlength="4" style="width: 5em;">
                  </td>
                </tr>
              </table>
            </fieldset>
          </form>
        </td>
        <td style="vertical-align: baseline;">
          <form id="filterForm" autocomplete="off">
            <fieldset>
              <legend>Filter</legend>
              <table>
                <tr>
                  <td>
                    <label for="low">Low</label>
                  </td>
                  <td>
                    <select id="low" name="low">
                    </select>
                  </td>
                </tr>
                <tr>
                  <td>
                    <label for="high">High</label>
                  </td>
                  <td>
                    <select id="high" name="high">
                    </select>
                  </td>
                </tr>
              </table>
            </fieldset>
          </form>
        </td>
        <td style="vertical-align: baseline;">
          <form id="filterForm" autocomplete="off">
            <fieldset>
              <legend>Action</legend>
              <table>
                <tr>
                  <td>
                    <label for="click">Click</label>
                  </td>
                  <td>
                    <button id="click" name="click">Drops</button>
                  </td>
                </tr>
              </table>
            </fieldset>
          </form>
        </td>
      </tr>
    </table>
    <table id="result" style="vertical-align: top;"></table>
    <script>
      class ChestDropper {
        static constants = {
          'unique': 250,
          'set': 500,
          'rare': 600,
          'magic': 0
        }

        async setup () {
          const d2data = new Diablo2Data()
          this.d2data = d2data
          await d2data.load()
          const typeList = d2data.TypeList()
          const tree = new TreasureTree(d2data.treasureClassEx(), typeList, d2data.weapons(), d2data.armor())
          this.tree = tree
          this.clazzes = new Set(typeList.expand('clas'))
          // very cool blizzard, thank you
          const diffs = ['', ' (N)', ' (H)']
          const acts = [1, 2, 3, 4, 5]
          const abcs = ['A', 'B', 'C']
          this.chestTcs = []
          diffs.forEach(diff => {
            acts.forEach(act => {
              abcs.forEach(abc => {
                this.chestTcs.push(`Act ${act}${diff} Chest ${abc}`)
              })
            })
          })
          this.misc = this.d2data.misc()
          this.weapons = this.d2data.weapons()
          this.armor = this.d2data.armor()
          this.itemTypes = this.d2data.itemTypes()
          this.itemRatio = this.d2data.itemRatio()
          this.uniques = this.d2data.uniqueItems()
        }

        simulateRegular ({ treasureClass, itemLevel, seed, chestDropLevel, locked = 0, magicFind = 0, forcedQuality = 0, dropClass = 1, confirmRarity = false }) {
          const random = new D2Random()
          random.lower(seed)
          const drops = []
          let i = 1 + locked
          while (i-- > 0) {
            this.tree.simulate({
              dc: dropClass,
              id: treasureClass,
              rng: n => random.max(n),
              cb: ({ id }, tc) => {
                let dropRarity = forcedQuality
                const item = this.findItem(id)
                const itemType = this.findItemType(id)
                if (!forcedQuality) {
                  if (itemType.Normal === '1') {
                    dropRarity = 'normal'
                  }
                  if (item.unique === '1' || (itemType.Magic === '1' && item.quest === '1')) {
                    dropRarity = 'unique'
                  }
                  if (!dropRarity) {
                    const passedRarity = rarity => {
                      const p = this.p(id, rarity, magicFind, chestDropLevel, tc[rarity])
                      if (p <= 0 || random.max(p) < 128) {
                        return true
                      }
                      return false
                    }
                    dropRarity = ['unique', 'set'].find(passedRarity)
                    if (!dropRarity) {
                      if (itemType.Rare === '1' && passedRarity('rare')) {
                        dropRarity = 'rare'
                      }
                      if (!dropRarity && (itemType.Magic === '1' || passedRarity('magic'))) {
                        dropRarity = 'magic'
                      }
                    }
                    if (!dropRarity) {
                      const highQualityRatio = this.findRatio(id, 'HiQuality')
                      let p = (highQualityRatio.base - ~~((chestDropLevel - item.level) / highQualityRatio.divisor)) << 7
                      if (p <= 0 || random.max(p) < 128) {
                        dropRarity = 'high'
                      }
                      if (!dropRarity) {
                        const normalRatio = this.findRatio(id, 'Normal')
                        p = (normalRatio.base - ~~((chestDropLevel - item.level) / normalRatio.divisor)) << 7
                        if (p <= 0 || random.max(p) < 128) {
                          dropRarity = 'normal'
                        } else {
                          dropRarity = 'low'
                        }
                      }
                    }
                  }
                }
                drops.push({
                  id,
                  rarity: dropRarity
                })
                if (confirmRarity) {
                  dropRarity = this.getRealRarity(id, itemLevel, dropRarity, item, itemType)
                  const last = drops.at(-1)
                  last.downgrade = last.rarity
                  last.rarity = dropRarity
                }
              },
            })
          }
          return drops
        }

        getRealRarity (id, level, rarity, item, type) {
          // we only care about magic+
          // a superior/low/normal doesn't affect chest drops
          // unique
          // rare -> magic w/ prefix & suffix -> superior? -> normal
          // magic w/o prefix & suffix -> normal
          // low/high non-armor/weapon -> normal
          switch (rarity) {
            case 'unique': {
              if (type.unique === '1') {
                break
              }
              const eligible = this.uniques.all('code', id)
              if (eligible.length === 0) {
                return this.getRealRarity(id, level, 'rare', item, type)
              }
              if (!eligible.some(unique => unique.lvl <= level)) {
                return this.getRealRarity(id, level, 'rare', item, type)
              }
            }
            case 'set': {
              if (type.unique === '1') {
                break
              }
              const eligible = this.uniques.all('code', id)
              if (eligible.length === 0) {
                return this.getRealRarity(id, level, 'magic', item, type)
              }
              if (!eligible.some(set => set.lvl <= level)) {
                return this.getRealRarity(id, level, 'magic', item, type)
              }
            }
            case 'rare': {
              if (type.Rare !== '1') {
                return this.getRealRarity(id, level, 'magic', item, type)
              }
            }
            // for magic, if an item has no prefix/suffix, it cannot be magic...
            case 'magic': {
              break
            }
          }
          return rarity
        }

        p (id, rarity, magicFind, level, extra) {
          const item = this.findItem(id)
          const ratio = this.findRatio(id, rarity.substring(0, 1).toUpperCase() + rarity.substring(1).toLowerCase())
          return this.chance(magicFind, extra, level - item.level, rarity === 'magic', ratio.base, ratio.divisor, ratio.min, ChestDropper.constants[rarity])          
        }

        chance (magicFind, extra, difference, isMagic, rarityBase, divisor, min, constant) {
          const effectiveMF = !isMagic && magicFind > 10 ? ~~(magicFind * constant / (magicFind + constant)) : magicFind
          const div = ~~(difference / divisor)
          const chance = Math.max(min, ~~((rarityBase - div) * 12800 / (100 + effectiveMF)))
          const final = chance - ~~((chance * extra) / 1024)
          return final
        }

        findRatio (id, rarity) {
          const item = this.findItem(id)
          const clazzy = this.clazzes.has(id)
          const uber = item.szFlavorText !== undefined && (item.ubercode === id || item.ultracode === id) && item.type !== 'tpot' && !item.quest
          // assume version is ascending
          let ratio
          this.itemRatio.each(el => {
            const isClazzy = el['Class Specific'] === '1'
            const isUber = el['Uber'] === '1'
            if (clazzy === isClazzy && uber === isUber) {
              ratio = el
            }
          })
          return {
            base: Number(ratio[rarity]),
            divisor: Number(ratio[`${rarity}Divisor`]),
            min: Number(ratio[`${rarity}Min`]),
            class: clazzy,
            raw: ratio
          }
        }

        findItem (id) {
          let ret
          ret = this.misc.first('code', id)
          if (ret) {
            return ret
          }
          ret = this.weapons.first('code', id)
          if (ret) {
            return ret
          }
          ret = this.armor.first('code', id)
          if (ret) {
            return ret
          }
          throw new Error(`unknown item for id: ${id}`)
        }

        findItemType (id) {
          return this.itemTypes.first('Code', this.findItem(id).type)
        }
      }
      class ChestPU {
        static actZones = [
          'Act 1 - Town',
          'Act 2 - Town',
          'Act 3 - Town',
          'Act 4 - Town',
          'Act 5 - Town'
        ]
        // https://github.com/ThePhrozenKeep/D2MOO/blob/559def2d8fd94e1d2f959fa6e4f907a0f221795f/source/D2Game/src/OBJECTS/ObjMode.cpp#L3909
        static levelIds = ['2', '37', '41', '73', '76', '102', '104', '108', '109', '132']

        constructor () {
          document.querySelectorAll('form').forEach(form => {
            form.onsubmit = e => {
              e.preventDefault()
            }
          })
        }

        async setup () {
          this.dropper = new ChestDropper()
          await this.dropper.setup()
          this.d2data = this.dropper.d2data
          const version = this.dropper.d2data.version
          this.strings = new StringResolver([
            `data/${version}/global/excel/patchstring.tbl`,
            `data/${version}/global/excel/expansionstring.tbl`,
            `data/${version}/global/excel/string.tbl`,
          ])
          await this.strings.load()
          this.runes = []          
          for (let i = 1; i <= 33; ++i) {
            const rune = `r${i.toString().padStart(2, '0')}`
            this.runes.push({
              id: `${rune}s`,
              name: this.strings.get(rune).substring(4)
            })
          }
          this.zones = [[]]
          const levels = this.d2data.levels()
          this.levels = levels
          let i = 0
          levels.each(level => {
            if (!level.Id) {
              return
            }
            // act exists in levels.txt but the game does this?
            if (i < 5 && level.Id === levels.first('Name', ChestPU.actZones[i]).Id) {
              this.zones.at(-1).set = new Set(this.zones.at(-1))
              this.zones.push([])
              i += 1
            } else {
              this.zones.at(-1).push(level)
            }
          })
          this.zones.shift()
          this.config()
          this.configRunes()
          document.getElementById('configForm').onchange = e => {
            this.config()
          }
          document.getElementById('click').onclick = e => {
            this.simulate()
          }
        }

        values () {
          return Object.fromEntries(new FormData(document.getElementById('configForm')))
        }

        filters () {
          return Object.fromEntries(new FormData(document.getElementById('filterForm')))
        }

        config () {
          const previous = this.lastValues || {}
          const values = this.values()
          const valuesKey = JSON.stringify(values)
          if (valuesKey === this.lastValues) {
            return
          }
          this.lastValues = values
          this.lastValuesKey = valuesKey
          if (previous.chestType !== values.chestType) {
            this.configChestOpt(values)
          }
          if (previous.act !== values.act) {
            this.configAct(values)
          }
        }

        configChestOpt (values) {
          const opt = document.getElementById('chestOpt')
          opt.innerHTML = ''
          const frag = document.createDocumentFragment()
          switch (values.chestType) {
            case 'normal': {
              const types = ['Unlocked', 'Locked']
              types.forEach((type, idx) => {
                const el = document.createElement('option')
                el.value = idx
                el.textContent = type
                frag.appendChild(el)
              })
              frag.firstElementChild.setAttribute('selected', true)
              break
            }
            default: {
              throw new Error(`unknown chest type: ${values.chestType}`)
            }
          }
          opt.appendChild(frag)
        }

        configAct (values) {
          const zone = document.getElementById('zone')
          zone.innerHTML = ''
          const frag = document.createDocumentFragment()
          this.zones[values.act].forEach(zone => {
            const el = document.createElement('option')
            el.value = zone.Id
            el.textContent = this.strings.get(zone.LevelName)
            frag.appendChild(el)
          })
          frag.lastElementChild.setAttribute('selected', true)
          zone.appendChild(frag)
        }

        configRunes () {
          const frag = document.createDocumentFragment()
          this.runes.forEach(({ id, name }) => {
            const el = document.createElement('option')
            el.value = id
            el.textContent = name
            frag.appendChild(el)
          })
          frag.lastElementChild.setAttribute('selected', true)
          const low = document.getElementById('low')
          low.innerHTML = ''
          low.appendChild(frag.cloneNode(true))
          const high = document.getElementById('high')
          high.innerHTML = ''
          high.appendChild(frag)
        }

        simulate () {
          const values = this.values()
          const zone = this.levels.first('Id', values.zone)
          const zoneName = this.strings.get(zone.LevelName)
          const act = Number(values.act)
          const difficulty = Number(values.difficulty)
          const levelKey = `MonLvl${difficulty}Ex`
          const level = Number(zone[levelKey])
          const minLevel = Number(this.levels.first('Id', ChestPU.levelIds[act * 2])[levelKey])
          const maxLevel = Number(this.levels.first('Id', ChestPU.levelIds[act * 2 + 1])[levelKey])
          // extra chest tc for each 1/3 of an act
          const offset = ~~((Math.abs(maxLevel - minLevel) + 1) / 3)
          let idx = 0
          if (level > minLevel + offset) {
            idx = 1
            idx += level >= minLevel + 2 * offset
          }
          const magicFind = Number(values.magicFind)
          const locked = Number(values.chestOpt)
          const tcIdx = 3 * (difficulty * 5 + act) + idx
          const treasureClass = this.dropper.chestTcs[tcIdx]
          const dropClass = Number(values.players)
          const seedLimit = (1 << 16) - 2
          const filters = this.filters()
          const lowIdx = this.runes.findIndex(rune => rune.id === filters.low)
          const set = {}
          for (let i = lowIdx; i < this.runes.length; ++i) {
            set[this.runes[i].id] = true
            if (this.runes[i].id === filters.high) {
              break
            }
          }
          let found = []
          for (let i = 0; i < seedLimit; ++i) {
            const res = this.dropper.simulateRegular({
              treasureClass,
              seed: i,
              chestDropLevel: idx,
              magicFind,
              locked,
              dropClass
            })
            if (res.some(drop => set[drop.id])) {
              found.push({
                seed: i,
                drops: res
              })
            }
          }
          this.result({
            config: {
              values,
              filters
            },
            computed: {
              treasureClass,
              zone: zoneName
            },
            drops: found
          })
        }

        result (output) {
          const query = document.createElement('td')
          query.style.verticalAlign = 'top'
          this.populateQuery(output, query)
          const result = document.createElement('td')
          result.style.verticalAlign = 'top'
          this.populateResult(output, result)
          const tr = document.createElement('tr')
          tr.appendChild(query)
          tr.appendChild(result)
          const tbl = document.getElementById('result')
          tbl.prepend(tr)
        }

        populateQuery ({ config, computed }, query) {
          const p = text => {
            const el = document.createElement('p')
            el.textContent = text
            return el
          }
          const difficulty = ['Normal', 'Nightmare', 'Hell'][config.values.difficulty]
          const players = config.values.players
          const chestType = ({
            normal: 'Normal'
          })[config.values.chestType]
          const chestOpt = ({
            normal: ['Unlocked', 'Locked']
          })[config.values.chestType][config.values.chestOpt]
          const act = `Act ${config.values.act + 1}`
          const magicFind = config.values.magicFind
          const low = this.runes.find(rune => rune.id === config.filters.low).name
          const high = this.runes.find(rune => rune.id === config.filters.high).name
          const zone = computed.zone
          const treasureClass = computed.treasureClass
          query.appendChild(p(`${difficulty} "${zone}" P:${players} MF:${magicFind}`))
          query.appendChild(p(`Treasure: ${treasureClass}`))
          query.appendChild(p(`${chestType} ${chestOpt}`))
          query.appendChild(p(`${low} to ${high}`))
        }

        populateResult ({ drops }, result) {
          const txt = (text, type = 'p') => {
            const el = document.createElement(type)
            el.textContent = text
            return el
          }
          const style = getComputedStyle(document.documentElement)
          const color = rarity => {
            return style.getPropertyValue(`--d2-color-${rarity}`)
          }
          const max = (1 << 16) - 2
          result.appendChild(txt(`${drops.length} of ${max} ~ ${(drops.length / max * 100).toFixed(6)}%`))
          drops.forEach((drop, idx) => {
            const el = document.createElement('p')
            el.appendChild(txt(`${idx + 1}.`, 'span'))
            el.append(' ')
            drop.drops.forEach(({ id, rarity }) => {
              const name = this.getItemName(id)
              el.appendChild(txt(`[${name}]`, 'span'))
              el.append(' ')
              el.lastElementChild.style.color = !name.endsWith('Rune') ? color(rarity) : color('rune')
            })
            result.appendChild(el)
          })
        }

        getItemName (id) {
          const name = this.strings.get(this.dropper.findItem(id).namestr)
          return name.replace(/\xC3.../g, '')
        }
      }
      new ChestPU().setup()
    </script>
  </body>
</html>
