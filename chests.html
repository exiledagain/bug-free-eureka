<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <link rel="stylesheet" href="css/common.css">
    <script src="d2data.js"></script>
  </head>
  <body>
    <script>
      class ChestDropper {
        static constants = {
          'unique': 250,
          'set': 500,
          'rare': 600,
          'magic': 0
        }

        constructor () {
        }

        async setup () {
          const d2data = new Diablo2Data()
          this.d2data = d2data
          await d2data.load()
          const typeList = d2data.TypeList()
          const tree = new TreasureTree(d2data.treasureClassEx(), typeList, d2data.weapons(), d2data.armor())
          const random = new D2Random()
          const oldmax = random.max
          random.max = n => {
            let res = oldmax.call(random, n)
            // console.log('random', n, res)
            return res
          }
          const forcedQuality = 0
          const chestDropLevel = 0
          const magicFind = 30
          this.clazzes = new Set(typeList.expand('clas'))
          const simulate = (tc, seed, locked) => {
            random.lower(seed)
            const drops = []
            let i = 1 + locked
            while (i-- > 0) {
              tree.simulate({
                dc: 1,
                id: tc,
                rng: n => random.max(n),
                cb: ({ id }, tc) => {
                  let dropRarity = forcedQuality
                  if (!forcedQuality) {
                    const item = this.findItem(id)
                    const itemType = this.findItemType(id)
                    if (itemType.Normal === '1') {
                      // must be normal
                      dropRarity = 'normal'
                    }
                    if (item.unique === '1' || (itemType.Magic === '1' && item.quest === '1')) {
                      // must be unique
                      dropRarity = 'unique'
                    }

                    if (!dropRarity) {
                      dropRarity = Object.keys(ChestDropper.constants).find(rarity => {
                        const p = this.p(id, rarity, magicFind, chestDropLevel, tc[rarity])
                        if (p <= 0 || random.max(p) < 128) {
                          return true
                        }
                        return false
                      })
                      if (!dropRarity) {
                        const item = this.findItem(id)
                        const highQualityRatio = this.findRatio(id, 'HiQuality')
                        let p = (highQualityRatio.base - ~~((chestDropLevel - item.level) / highQualityRatio.divisor)) << 7
                        if (p <= 0 || random.max(p) < 128) {
                          dropRarity = 'high'
                        }
                        if (!dropRarity) {
                          const normalRatio = this.findRatio(id, 'Normal')
                          p = (normalRatio.base - ~~((chestDropLevel - item.level) / normalRatio.divisor)) << 7
                          if (p <= 0 || random.max(p) < 128) {
                            dropRarity = 'normal'
                          } else {
                            dropRarity = 'low'
                          }
                        }
                      }
                    }
                  }
                  drops.push({
                    id,
                    rarity: dropRarity
                  })
                },
              })
            }
            return drops
          }
          let tcs = [
            'Act 5 (H) Chest C',
            // 'Act 5 (H) Chest B',
            // 'Act 5 (H) Chest A',
            // 'Act 4 (H) Chest C',
            // 'Act 4 (H) Chest B',
            // 'Act 4 (H) Chest A',
            // 'Act 3 (H) Chest C',
            // 'Act 3 (H) Chest B',
            // 'Act 3 (H) Chest A',
          ]
          // for (let i = 0x3; i < 0x3 + 1; ++i) {
          tcs.forEach(tc => {
            for (let i = 0; i < (1 << 16) - 2; ++i) {
              const drops = simulate(tc, i, false)
              // console.log(drops)
              // if (drops.some(el => el.id === 'r33s')) {
              // zmb, 3x gold
              if (drops.length === 2) {
                if (drops[0].id === 'gld' || drops[1].id === 'gld') {
                  if (drops[0].id === 'isc' || drops[1].id === 'isc') {
                    console.log(i, drops)
                  }
                }
              }
            }
          })
          console.log('done')
        }

        p (id, rarity, magicFind, level, extra) {
          const item = this.findItem(id)
          const ratio = this.findRatio(id, rarity.substring(0, 1).toUpperCase() + rarity.substring(1).toLowerCase())
          return this.chance(magicFind, extra, level - item.level, rarity === 'magic', ratio.base, ratio.divisor, ratio.min, ChestDropper.constants[rarity])          
        }

        chance (magicFind, extra, difference, isMagic, rarityBase, divisor, min, constant) {
          const effectiveMF = !isMagic ? ~~(magicFind * constant / (magicFind + constant)) : magicFind
          const div = ~~(difference / divisor)
          const chance = Math.max(min, ~~((rarityBase - div) * 12800 / (100 + effectiveMF)))
          const final = chance - ~~((chance * extra) / 1024)
          return final
        }

        findRatio (id, rarity) {
          const item = this.findItem(id)
          const clazzy = this.clazzes.has(id)
          const uber = item.szFlavorText !== undefined && (item.ubercode === id || item.ultracode === id) && item.type !== 'tpot' && !item.quest
          // assume version is ascending
          let ratio
          this.d2data.itemRatio().each(el => {
            const isClazzy = el['Class Specific'] === '1'
            const isUber = el['Uber'] === '1'
            if (clazzy === isClazzy && uber === isUber) {
              ratio = el
            }
          })
          return {
            base: Number(ratio[rarity]),
            divisor: Number(ratio[`${rarity}Divisor`]),
            min: Number(ratio[`${rarity}Min`]),
            class: clazzy,
            raw: ratio
          }
        }

        findItem (id) {
          let ret
          ret = this.d2data.misc().first('code', id)
          if (ret) {
            return ret
          }
          ret = this.d2data.weapons().first('code', id)
          if (ret) {
            return ret
          }
          ret = this.d2data.armor().first('code', id)
          if (ret) {
            return ret
          }
          throw new Error(`unknown item for id: ${id}`)
        }

        findItemType (id) {
          return this.d2data.itemTypes().first('Code', this.findItem(id).type)
        }
      }      
      new ChestDropper().setup()
    </script>
  </body>
</html>
